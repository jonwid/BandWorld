using System;
using System.IO;
using System.Reflection;
using JTRazorPortable;

namespace JTRazorPortable
{
    // This is the common base class for the code generated by the razor
    // compiler.  It defines some of the functions behind the directives
    // that can be called from the razor views.
    // Theres a little bit of trickery here to help the MVCManager do its thing.
	// This was copied from the generated .cs for one of the razor views
	public abstract class ViewBase
	{
        public string ViewName { get; set; }
		private static string scheme;
		public static string UrlScheme {
			get { return scheme ?? "hybrid:"; }
			set { scheme = value; }
		}
        public string Layout { get; set; }
        public HtmlHelper Html { get; private set; }
        public UrlHelper Url { get; private set; }
        public MVCManager MVCManager { get; set; }
        private object CachedModel;
        public System.IO.TextWriter __razor_writer;
        public static string RenderBodyPlaceholder = "__RenderBody__";
        public static string RenderSectionPlaceholder = "__RenderSection__";

        public ViewBase()
        {
            Layout = "~/Shared/_Layout.cshtml";
        }

        public object RequestContext
        {
            get
            {
                return null;
            }
        }

        public IHtmlString RenderBody()
        {
            return new HtmlString(RenderBodyPlaceholder);
        }

        public IHtmlString RenderSection(string name)
        {
            return new HtmlString(RenderSectionPlaceholder + "(" + name + ", true)");
        }

        public IHtmlString RenderSection(string name, bool required)
        {
            return new HtmlString(RenderSectionPlaceholder + "(" + name + ", " + (required ? "true" : "false") + ")");
        }

        public delegate void SectionWriter();
        public void DefineSection(string name, SectionWriter sectionWriter)
        {
            if (sectionWriter != null)
            {
                using (var razorWriter = new StringWriter())
                {
                    var saveWriter = __razor_writer;
                    __razor_writer = razorWriter;
                    sectionWriter();
                    __razor_writer = saveWriter;
                    string sectionHtml = razorWriter.ToString();
                    MVCManager.AddSection(name, sectionHtml);
                }
            }
        }

        public MVCManager Styles
        {
            get
            {
                return MVCManager;
            }
        }

        public MVCManager Scripts
        {
            get
            {
                return MVCManager;
            }
        }

        public object GetModel()
        {
            if (CachedModel != null)
                return CachedModel;

            Type type = GetType();
            PropertyInfo pi = type.GetRuntimeProperty("Model");
            object model = null;

            if (pi != null)
                model = pi.GetValue(this, null);

            return model;
        }

        public void SetModel(object model)
        {
            Type type = GetType();
            PropertyInfo pi = type.GetRuntimeProperty("Model");
            if (pi != null)
                pi.SetValue(this, model, null);
            CachedModel = model;
        }

        public string LayoutName
        {
            get
            {
                if (String.IsNullOrEmpty(Layout))
                    return Layout;
                return StringUtilities.GetBaseFileName(Layout);
            }
        }

        public TextWriter Writer
        {
            get
            {
                return __razor_writer;
            }
            set
            {
                __razor_writer = value;
            }
        }

		/// <summary>Executes the template and returns the output as a string.</summary>
		/// <returns>The template output.</returns>
		public string GenerateString ()
		{
			using (var sw = new System.IO.StringWriter ()) {
				Generate (sw);
				return sw.ToString ();
			}
		}

		/// <summary>Executes the template, writing to the provided text writer.</summary>
		/// <param name=""writer"">The TextWriter to which to write the template output.</param>
		public void Generate (System.IO.TextWriter writer)
		{
            ModelStateDictionary modelState;
            if (MVCManager.CurrentController != null)
                modelState = MVCManager.CurrentController.ModelState;
            else
                modelState = new ModelStateDictionary();
            Html = new HtmlHelper(writer, modelState);
			Url = new UrlHelper();
			__razor_writer = writer;
			Execute ();
			__razor_writer = null;
		}

		// This method is REQUIRED, but you may choose to implement it differently
		//
		/// <summary>Writes a literal value to the template output without HTML escaping it.</summary>
		/// <param name=""value"">The literal value.</param>
		protected void WriteLiteral (string value)
		{
			__razor_writer.Write (value);
		}

		// This method is REQUIRED if the template contains any Razor helpers, but you may choose to implement it differently
		//
		/// <summary>Writes a literal value to the TextWriter without HTML escaping it.</summary>
		/// <param name=""writer"">The TextWriter to which to write the literal.</param>
		/// <param name=""value"">The literal value.</param>
		protected static void WriteLiteralTo (System.IO.TextWriter writer, string value)
		{
			writer.Write (value);
		}

		// This method is REQUIRED, but you may choose to implement it differently
		//
		/// <summary>Writes a value to the template output, HTML escaping it if necessary.</summary>
		/// <param name=""value"">The value.</param>
		/// <remarks>The value may be a Action<System.IO.TextWriter>, as returned by Razor helpers.</remarks>
		protected void Write (object value)
		{
			WriteTo (__razor_writer, value);
		}

		// This method is REQUIRED if the template contains any Razor helpers, but you may choose to implement it differently
		//
		/// <summary>Writes an object value to the TextWriter, HTML escaping it if necessary.</summary>
		/// <param name=""writer"">The TextWriter to which to write the value.</param>
		/// <param name=""value"">The value.</param>
		/// <remarks>The value may be a Action<System.IO.TextWriter>, as returned by Razor helpers.</remarks>
		protected static void WriteTo (System.IO.TextWriter writer, object value)
		{
			if (value == null)
				return;

			var write = value as Action<System.IO.TextWriter>;
			if (write != null) {
				write (writer);
				return;
			}

			if (value is IHtmlString)
				writer.Write (value);
			else
				writer.Write(HttpUtility.HtmlEncode (value.ToString ()));
		}

		// This method is REQUIRED, but you may choose to implement it differently
		//
		/// <summary>
		/// Conditionally writes an attribute to the template output.
		/// </summary>
		/// <param name=""name"">The name of the attribute.</param>
		/// <param name=""prefix"">The prefix of the attribute.</param>
		/// <param name=""suffix"">The suffix of the attribute.</param>
		/// <param name=""values"">Attribute values, each specifying a prefix, value and whether it's a literal.</param>
		protected void WriteAttribute (string name, string prefix, string suffix, params Tuple<string,object,bool>[] values)
		{
			WriteAttributeTo (__razor_writer, name, prefix, suffix, values);
		}

		// This method is REQUIRED if the template contains any Razor helpers, but you may choose to implement it differently
		//
		/// <summary>
		/// Conditionally writes an attribute to a TextWriter.
		/// </summary>
		/// <param name=""writer"">The TextWriter to which to write the attribute.</param>
		/// <param name=""name"">The name of the attribute.</param>
		/// <param name=""prefix"">The prefix of the attribute.</param>
		/// <param name=""suffix"">The suffix of the attribute.</param>
		/// <param name=""values"">Attribute values, each specifying a prefix, value and whether it's a literal.</param>
		///<remarks>Used by Razor helpers to write attributes.</remarks>
		protected static void WriteAttributeTo (System.IO.TextWriter writer, string name, string prefix, string suffix, params Tuple<string,object,bool>[] values)
		{
			// this is based on System.Web.WebPages.WebPageExecutingBase
			// Copyright (c) Microsoft Open Technologies, Inc.
			// Licensed under the Apache License, Version 2.0
			if (values.Length == 0) {
				// Explicitly empty attribute, so write the prefix and suffix
				writer.Write (prefix);
				writer.Write (suffix);
				return;
			}

			bool first = true;
			bool wroteSomething = false;

			for (int i = 0; i < values.Length; i++) {
				Tuple<string,object,bool> attrVal = values [i];
				string attPrefix = attrVal.Item1;
				object value = attrVal.Item2;
				bool isLiteral = attrVal.Item3;

				if (value == null) {
					// Nothing to write
					continue;
				}

				// The special cases here are that the value we're writing might already be a string, or that the 
				// value might be a bool. If the value is the bool 'true' we want to write the attribute name instead
				// of the string 'true'. If the value is the bool 'false' we don't want to write anything.
				//
				// Otherwise the value is another object (perhaps an IHtmlString), and we'll ask it to format itself.
				string stringValue;
				bool? boolValue = value as bool?;
				if (boolValue == true) {
					stringValue = name;
				} else if (boolValue == false) {
					continue;
				} else {
					stringValue = value as string;
				}

				if (first) {
					writer.Write (prefix);
					first = false;
				} else {
					writer.Write (attPrefix);
				}

				if (isLiteral) {
					writer.Write (stringValue ?? value);
				} else {
					WriteTo (writer, stringValue ?? value);
				}
				wroteSomething = true;
			}
			if (wroteSomething) {
				writer.Write (suffix);
			}
		}

		// This method is REQUIRED. The generated Razor subclass will override it with the generated code.
		//
		///<summary>Executes the template, writing output to the Write and WriteLiteral methods.</summary>.
		///<remarks>Not intended to be called directly. Call the Generate method instead.</remarks>
		public abstract void Execute ();

	}
}

